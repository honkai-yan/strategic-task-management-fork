# 年份切换逻辑说明

## 核心概念

### 1. 真实年份 (realCurrentYear)
- **定义**: 系统实时捕捉的当前日期年份
- **来源**: `new Date().getFullYear()`
- **特点**: 动态计算，始终反映真实时间
- **示例**: 2026 年 1 月 4 日 → `realCurrentYear = 2026`

### 2. 工作年份 (currentYear)
- **定义**: 用户当前选中的工作年份
- **默认值**: 2025（当前工作年份）
- **特点**: 用户可通过年份选择器切换
- **用途**: 决定显示哪一年的数据

## 系统行为

### 初始化行为
```
真实日期: 2026-01-04
realCurrentYear: 2026 (实时捕捉)
currentYear: 2025 (默认工作年份)
availableYears: [2021, 2022, 2023, 2024, 2025, 2026, 2027]
```

### 年份状态判断

| 选中年份 | 真实年份 | 状态 | 模式 | 说明 |
|---------|---------|------|------|------|
| 2023 | 2026 | history | 只读 | 历史快照 |
| 2024 | 2026 | history | 只读 | 历史快照 |
| 2025 | 2026 | history | 可编辑 | 当前工作年份 |
| 2026 | 2026 | current | 只读 | 真实年份（历史数据） |
| 2027 | 2026 | future | 只读 | 未来规划 |

### 数据加载逻辑

```typescript
// strategic store 中的数据加载
loadIndicatorsByYear(year) {
  if (year === 2025) {
    // 加载 2025 年工作数据（可编辑）
    indicators.value = current2025Indicators
  } else if (year === 2023) {
    // 加载 2023 年历史数据（只读）
    indicators.value = indicators2023
  } else if (year === 2024) {
    // 加载 2024 年历史数据（只读）
    indicators.value = indicators2024
  } else if (year === 2026) {
    // 加载 2026 年历史数据（只读）
    indicators.value = indicators2026
  } else {
    // 其他年份：空数据
    indicators.value = []
  }
}
```

## 使用场景

### 场景 1: 系统启动
1. 真实日期: 2026-01-04
2. 系统默认显示: 2025 年数据（工作模式）
3. 用户可以编辑、下发、审批 2025 年的指标

### 场景 2: 查看历史数据
1. 用户点击年份选择器，选择 2024 年
2. 系统切换到 2024 年历史数据（只读模式）
3. 页面显示"当前处于历史快照模式（2024年），数据为只读状态"

### 场景 3: 查看 2026 年数据
1. 用户点击年份选择器，选择 2026 年
2. 系统切换到 2026 年历史数据（只读模式）
3. 显示 2026 年的指标数据（约 20 个指标）

### 场景 4: 切换回工作年份
1. 用户点击年份选择器，选择 2025 年
2. 系统切换回 2025 年工作数据（可编辑模式）
3. 之前的编辑内容不会丢失

## 技术实现

### timeContext Store
```typescript
// 实时捕捉真实年份
const realCurrentYear = computed(() => new Date().getFullYear())

// 默认工作在 2025 年
const currentYear = ref<number>(2025)

// 动态生成可用年份列表
function initAvailableYears() {
  const current = realCurrentYear.value // 2026
  const years = []
  for (let i = current - 5; i <= current + 1; i++) {
    years.push(i) // [2021, 2022, 2023, 2024, 2025, 2026, 2027]
  }
  availableYears.value = years
}
```

### strategic Store
```typescript
// 监听年份变化
watch(() => timeContext.currentYear, (newYear) => {
  loadIndicatorsByYear(newYear)
})

// 初始化流程
initializeIndicatorFields()        // 1. 初始化字段
saveCurrentIndicators()            // 2. 保存 2025 年数据
if (timeContext.currentYear !== 2025) {
  loadIndicatorsByYear(timeContext.currentYear) // 3. 切换数据
}
```

## 注意事项

1. **真实年份 vs 工作年份**: 系统能够识别真实年份（2026），但默认工作在 2025 年
2. **数据隔离**: 每个年份的数据独立存储，切换年份不会影响其他年份的数据
3. **只读模式**: 历史年份（< 2025）和未来年份（> 2025）均为只读模式
4. **工作模式**: 只有 2025 年是可编辑的工作模式
5. **数据持久化**: 2025 年的编辑会保存在 `current2025Indicators` 中，切换年份后再切回来不会丢失

## 未来扩展

如果需要支持多个工作年份（例如同时编辑 2025 和 2026），可以：
1. 将 `current2025Indicators` 改为 `Map<year, indicators>`
2. 添加"工作年份"配置，允许多个年份处于可编辑状态
3. 修改 `isReadOnly` 逻辑，基于工作年份列表判断
